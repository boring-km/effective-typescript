# 아이템 3. 코드 생성과 타입이 관계없음을 이해하기

### 타입스크립트 컴파일러
- 역할 1: 최신 TypeScript/JavaScript를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일(transpile)한다.
- 역할 2: 코드의 타입 오류를 체크한다.
- 이 두 가지 역할은 완벽히 독립적이다.

### 타입 오류가 있는 코드도 컴파일이 가능하다
- 컴파일은 타입 체크와 독립적으로 동작하기 때문에, 타입 오류가 있는 코드도 컴파일이 가능하다.

> **컴파일과 타입 체크**
> 코드에 오류가 있을 때 "컴파일에 문제가 있다"는 틀린 말이다.
> IDE에서 타입 체크를 해줄 뿐이지 실제로 컴파일을 해서 코드 생성을 한 것은 아니니까 잘 구분해서 사용하자.

- 문제가 생겨서 오류가 발생해도 실행이 되기 때문에 영향이 없는 다른 부분을 테스트 가능하다.
- 오류가 있을 때 컴파일 하지 않으려면 noEmitOnError를 설정하면 된다.

### 런타임에는 타입 체크가 불가능하다
- instanceof 체크는 런타임에 일어나지만, Rectangle은 타입이기 때문에 런타임 시점에 아무런 역할을 할 수 없다.
- 타입스크립트의 타입은 자바스크립트로 컴파일 되는 과정에서 모든 인터페이스, 타입, 타입 구문은 그냥 제거 된다.

### 타입 연산은 런타임에 영향을 주지 않는다
- 'as' 연산자는 타입 연산이므로 런타임 동작에 아무런 영향을 끼치지 않는다.

### 런타임 타입은 선언된 타입과 다를 수 있다
- 함수의 인수로 선언한 변수의 타입이 런타임에서는 지워지기 때문에 반드시 그 타입으로 값이 들어가리라는 보장이 없다.
- **언제든 달라질 수 있다는 것을 명심해야 한다.**

### 타입스크립트 타입으로는 함수를 오버로드 할 수 없다
- 함수 오버로딩을 지원하기는 하지만, 타입 수준에서만 동작한다.
- 구현체는 오직 하나뿐이다.

```typescript
// 코드 작성
function add(a: number, b: number): number { return a + b; }
function add(a: string, b: string): string { return a + b; }
```

```javascript
// 실제
function add(a, b) {
  return a + b;
}
```

### 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다
- 타입과 타입 연산자는 자바스크립트 변환 시점에 제거되기 때문에 런타임의 성능에 아무런 영향을 주지 않는다.

> **타입스크립트 주의사항 일부...**
> 런타임 오버헤드가 없는 대신, 타입스크립트 컴파일러는 '빌드타임' 오버헤드가 있다. 오버헤드가 커지면 타입 체크를 건너 뛸 수도 있다.
> 제너레이터 함수가 ES5 타깃으로 컴파일되려면, 타입스크립트 컴파일러는 호환성을 위한 특정 헬퍼 코드를 추가할 것이다. (타입과 무관)

### 요약
- 코드 생성은 타입 시스템과 무관하다.
- 타입스크립트 타입은 런타임 동작과 성능에 영향을 주지 않는다.
- 타입 오류가 존재하더라도 코드 생성(컴파일)은 가능하다.
- 타입스크립트 타입은 런타임에 사용할 수 없다. 런타임에 타입을 지정하려면, tagged union 이나 클래스로 제공하는 방법이 있다.